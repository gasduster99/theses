rm(list=ls())

library(tgp)

#
rosenbrock = function(x){
        out = 100*(x[,1]^2 - x[,2])^2 + (x[,1] - 1)^2
        return(out)
}

#
rastrigin = function(x){
        out = matrix(NaN, nrow=dim(x)[1], ncol=1)
        for (i in seq(1, dim(x)[1])){
                ex = x[i,]
                out[i] = 10*length(ex)+sum(ex^2-10*cos(2*pi*ex))
        }
        return(out)
}

#
easom = function(x){
        #out = -apply(cos(x), 1, prod) * exp(-apply((x-pi)^2, 1, sum))
        out = matrix(NaN, nrow=dim(x)[1], ncol=1)
        for(i in seq(1, dim(x)[1])){
                ex = x[i,]
                out[i] = -prod(cos(ex)) * exp( -sum((ex-pi)^2) )
        }
        return(out)
}

#typically keep will be W*sLen (ie. number of points looking back (W) by the samples per point)
slideWindow = function(oldStuff, newStuff, keep){
        out = c(oldStuff, newStuff)
        outl = length(out)
        left = max((outl-(keep-1)), 1)
        out = out[left:outl]

        return( out )
}

#
LNToN = function(LNSamples){
	#log-normal stats
        wm = mean(LNSamples)
        wv = var(LNSamples)
        #associated normal stats
        wmu = log( (wm^2)/(wv+wm^2)^0.5 )
        ws2 = log( 1 + (wv/(wm^2)) )
        #
        #           LN Stats    N Stats
        out = list( c(wm, wv), c(wmu, ws2) )
}

#
slice = function(x, n){
        out = split(x, as.integer((seq_along(x) - 1) / n))
        return(out)
}

#
getVect = function(outThing, LNNFlag, MVFlag){
        outVect = matrix(NA, nrow=length(outThing), ncol=1)
        if( LNNFlag=="LN" ){ lnn=1 }
        if( LNNFlag=="N" ){ lnn=2 }
        if( MVFlag=="M" ){ mv=1 }
        if( MVFlag=="V" ){ mv=2 }
        for( i in 1:length(outThing) ){
                outVect[i] = outThing[[i]][[lnn]][mv]
        }
        #
        return( outVect )
}

#
output = function(isOut){
	#
	if(isOut){
		#Figure 1
        	pdf(sprintf("bestZ%s.pdf", name))
        	plot( seq(1, it), ZMax,
        	        "l",
        	        xlab="Iteration Number",
        	        ylab="Objective Value",
        	        main="Best Z Value",
        	        ylim=c(tMin, max(ZMax))
        	)
        	#abline( h=tMin, lty=3 )
        	#legend("topright", c("\nBest\n Z Value", "\nLiterature \nMinimum", NA),
        	#       lty=c(1, 3, NA)
        	#)
        	dev.off()
        	#
        	ewmaOut = ewma( rev(mmu)[1:W], lambda=lambda, newdata=rev(mmu)[W:length(mmu)], plot=F )
        	testOut = rev(test1())
        	fudge = sample(rev(sort(ewmaOut$statistics))[1:3], 1)#sort(mm)[1:5], 1)
        	min2 = min(mmu, ewmaOut$y, ewmaOut$limits)
        	max2 = max(mmu, ewmaOut$y, ewmaOut$limits)
        	#
        	#Figure 2
        	#dev.new()
        	pdf(sprintf("ewmaConvChart%s.pdf", name))
        	plot( seq(1, it), rev(c(ewmaOut$statistics, ewmaOut$newstats)),
        	        pch=3,
        	        ylim=c(min2, max2+1),
        	        xlab="Iteration Number",
        	        ylab="Summary Statistics",
        	        main="EWMA Convergence Chart"
        	)
        	lines( ewmaOut$x, rev(ewmaOut$y) )
        	lines( seq(1, it), rev(ewmaOut$limits[,1]), lty=2 )
        	lines( seq(1, it), rev(ewmaOut$limits[,2]), lty=2 )
        	points( ewmaOut$x, rev(ewmaOut$y), pch=20 )
        	points( ewmaOut$x[testOut], rev(ewmaOut$y)[testOut], pch=19, col="red" )
        	abline( v=(it+0.5)-W, lty=3 )
        	abline( h=ewmaOut$center )
        	legend( "topright", c(expression(Y[i]), expression(Z[i]*" Violation"), expression(Z[i]*" Control"), "Control Limit", NA,"\nControl Window\nBoundary"),
        	        pch=c(3 , 19, 20, NA, NA, NA),
        	        lty=c(NA, NA, NA, 2, 3, NA),
        	        col=c("black", "red", "black", "black", "black", NA)
        	)
        	dev.off()
	}
}

#
meat = function(init, it){
	#
	#UNPACK INPUTS
	#

        #[[1]]:X; [[2]]:Z; [[3]]:Zmax; [[4]]:wSamples; [[5]]:maxes; [[6]]:out; [[7]]:mcmcSize    
        X = init[[1]]
        Z = init[[2]]
        Zmax = init[[3]]
        samples = init[[4]]
        maxes = init[[5]]
        out = init[[6]]
        sLen = init[[7]]

	#
	#OPTIMIZE
	#

        #               
        out = optim.step.tgp(f, X=X, Z=Z, rect=rect, prev=out, improv=c(1,n), trace=T, verb=0 )  
        ex = matrix(out$X, ncol=em)
        fex = f(ex)
        X = rbind(X, ex)
        Z = c(Z, fex)
        Zmax = c(Zmax, min(Z))
        #
        improvSamples = out$obj$trace$preds$improv
        EimprovAll = out$obj$improv
        maxI = which( EimprovAll$rank==1 )
        maxSamples = unlist( improvSamples[maxI] )  
        samples = c(samples, maxSamples)
        #
	m = mean(maxSamples)
        maxes = c(maxes, m)
	sLen = length(maxSamples)
	#wSamples = slideWindow(wSamples, maxSamples, W*sLen)
        #wm = mean(wSamples) 

 	#
        return( list(X, Z, Zmax, samples, maxes, out, sLen) )
}

#
#MAIN
#

#fiddlers
isConverge = F
W = 10
makeOut = T
#
f = rosenbrock
rect = cbind(c(-2, -3), c(2, 5))
##
#f = rastrigin
#rect = cbind(c(-2.5, -2.5), c(2.5, 2.5))
#
#intializing
it = 1
X = lhs(40, rect)
Z = f(X)
Zmax = c(min(Z))
samples = c()
maxes = c()#matrix(NaN, nrow=M, ncol=1)
out = NULL
sLen = NULL
#wSamples = c()
#[[1]]:X; [[2]]:Z; [[3]]:Zmax; [[4]]:wSamples; [[5]]:maxes; [[6]]:out; [[7]]:sLen
init = list(X, Z, Zmax, samples, maxes, out, sLen)
while( !isConverge ){
	#
        init = meat(init, it)
	#[[1]]:X; [[2]]:Z; [[3]]:Zmax; [[4]]:wSamples; [[5]]:maxes; [[6]]:out; [[7]]:mcmcSize
        X = init[[1]]
        Z = init[[2]]
        Zmax = init[[3]]
        samples = init[[4]]
        maxes = init[[5]]
        out = init[[6]]
        sLen = init[[7]]
	#
	sEnd = length(samples)
        back = W*mcmcSize
        lEnd = max(1, sEnd-back)
        wSamples = samples[seq(lEnd, sEnd)]
        mSamples = slice(samples, mcmcSize)
	#
	wOut = LNToN(wSamples)
        wm = wOut[[1]][1]
        wv = wOut[[1]][2]
        wmu = wOut[[2]][1]
        ws2 = wOut[[2]][2]
	#
        mOut = lapply(mSamples, LNToN)
        mm = getVect(mOut, "LN", "M")
        mv = getVect(mOut, "LN", "V")
        mmu = getVect(mOut, "N", "M")
        ms2 = getVect(mOut, "N", "V")
	#
	ewmaOut = ewma( rev(mmu)[1:W], lambda=lambda, newdata=rev(mmu)[W:length(mmu)], plot=F )
	#isConverge = ewmaOut$y>ewmaOut$limits[,2] | ewmaOut$y<ewmaOut$limits[,1]
	#
	output( makeOut )
	init = list(X, Z, Zmax, samples, maxes, out, sLen)
	it = it+1
        #save.image(sprintf("seaSave%s%s.RData", what, size))#dState))
}






























##
        #samLower = quantile(wSamples, probs=pnorm(-sig, 0, 1))
        #samUpper = quantile(wSamples, probs=pnorm(sig, 0, 1))
        ##
        ##OUTPUT
        #layout( matrix(c(1, 2, 3), nrow=1, ncol=3) )
        ##
        ##Figure 1
        #plot( seq(1, it+1), Zmax,
        #        "l",
        #        xlab="Sweeps",
        #        ylab="Value",
        #        main="Best Z Value"
        #)       
        ## 
        ##Figure 2
        #L = length(seq(1, it))
        #left = max((L-(W-1)), 1)
        #plot( seq(1, it), maxes[1:it],
        #        main=sprintf('Sweeps: %d\n', it),
        #        ylab='Max Improvement\n',
        #        col=c(rep("black", L-1), "green"),
        #        ylim=c(0, max(maxes[1:it], samUpper))
        #)
        ##Sample Intervals
        #segments(    1, samUpper, left, samUpper, col="blue", lty=2)
        #segments(    1, samLower, left, samLower, col="blue", lty=2)
        #segments( left, samUpper,   it, samUpper, col="blue")
        #segments( left, samLower,   it, samLower, col="blue")
        ##BarBar
        #segments( left, wm, it, wm, col="black")
        ##
        ##Figure 3
        #hist( wSamples, add=F, freq=F,
        #        main="Window Samples"
        #)
        #abline( v=samUpper, col="blue")
        #abline( v=samLower, col="blue")
        #abline( v=m, col='green' )
        #abline( v=wm, col='black' )
        #legend("topright",
        #        legend=c(sprintf("%0.4f%s (%d\\sigma)\nLog-N Interval\n", pnorm(sig, 0, 1)-pnorm(-sig, 0, 1), "%", sig), sprintf("%0.4f%s (%d\\sigma)\nSample Interval\n", pnorm(sig, 0, 1)-pnorm(-sig, 0, 1), "%",sig), "x-bar", "x-bar-bar"),
        #        col=c("red", "blue", "green", "black"),
        #        lty=1
        #)
